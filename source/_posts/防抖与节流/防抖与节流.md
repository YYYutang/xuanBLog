---
title: 防抖与节流
categories: Javascript
tags: [Javascript,前端]
cover: /picture/javascript.jpg
date: 2024-03-05 15:12
---



## 防抖（debounce）

所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

![](image_VtWslySXRU.png)

### 使用场景

1.  搜索框搜索输入，需要等到用户最后一次输入完再发送请求
2.  手机号、邮箱验证输入检测

### 实现底层

简单的实现：

需求：当鼠标在box里滑动时，box里的数字就加一。但如果鼠标每移动1px就加1，数字变化会非常频繁，非常浪费性能。

```javascript
const box=doucment.querySelector('.box')
let i=1
function mouseMove(){
  box.innerHTML=i++
}
box.addEventListener('mousemove',mouseMove)
```

#### lodash库

```javascript
_.debounce(func, [wait=0], [options={}])
```

使用说明：

-   创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。&#x20;
-   debounced（防抖动）函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。
-   可以提供一个 options（选项） 对象决定如何调用 func 方法，options.leading 与|或 options.trailing 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）。
-   func 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。&#x20;
-   后续调用的 debounced（防抖动）函数返回是最后一次 func 调用的结果。

```javascript
<script>
    const box = document.querySelector('.box')
    let i = 1  // 让这个变量++
    // 鼠标移动函数
    function mouseMove() {
      box.innerHTML = ++i
      // 如果里面存在大量操作 dom 的情况，可能会卡顿
    }

    // box.addEventListener('mousemove', mouseMove)
    // lodash 节流写法
    // box.addEventListener('mousemove', _.throttle(mouseMove, 500))
    // lodash 防抖的写法
    box.addEventListener('mousemove', _.debounce(mouseMove, 500))

  </script>

```

#### 手动实现

核心思想是使用定时器（setTimeout）来实现。

1．声明定时器变量

2．每次鼠标移动(事件触发）的时候都要先判断是否有定时器，如果有先清除以前的定时器

3．如果没有定时器，则开启定时器，存入到定时器变量里面

4．定时器里面写函数调用

```javascript
  <script>
    const box = document.querySelector('.box')
    let i = 1  // 让这个变量++
    // 鼠标移动函数
    function mouseMove() {
      box.innerHTML = ++i
      // 如果里面存在大量操作 dom 的情况，可能会卡顿
    }
    // 防抖函数
    function debounce(fn, t) {
      let timeId
      return function () {
        // 如果有定时器就清除
        let context = this; // 保存this指向
        let args = arguments; // 拿到event对象
        if (timeId) clearTimeout(timeId)
        // 开启定时器 200
        timeId = setTimeout(function () {
          func.apply(context, args)
        }, t)
      }
    }
    // box.addEventListener('mousemove', mouseMove)
    box.addEventListener('mousemove', debounce(mouseMove, 200))

  </script>
```

## 节流（throttle）

所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。

![](image_Y7oeuJBte1.png)

### 使用场景

鼠标移动mousemove、页面尺寸缩放resize、滚动条滚动scroll等等

### 实现底层

简单的实现：

需求：当鼠标在box里滑动时，不管移动多少次，box里的数字每隔500ms才加一。

#### lodash库

```javascript
_.throttle(func, [wait=0], [options=])
```

-   创建一个节流函数，在 wait 秒内最多执行 `func` 一次的函数。&#x20;
-   该函数提供一个 `cancel` 方法取消延迟的函数调用以及 `flush` 方法立即调用。&#x20;
-   可以提供一个 options 对象决定如何调用 `func` 方法， options.leading 与|或 options.trailing 决定 wait 前后如何触发。&#x20;
-   `func` 会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次 `func` 调用的结果。

```javascript
 <script>
    const box = document.querySelector('.box')
    let i = 1  // 让这个变量++
    // 鼠标移动函数
    function mouseMove() {
      box.innerHTML = ++i
      // 如果里面存在大量操作 dom 的情况，可能会卡顿
    }
      box.addEventListener('mousemove', _.throttle(mouseMove, 500))
  </script>
```

#### 手动实现

1.  声明一个定时器变量
2.  当鼠标每次滑动，都先判断是否有定时器了，如果有定时器则不开启新定时器
3.  如果没有定时器则开启定时器，记得存到变量里面
    -定时器里面调用执行的函数
    -定时器里面要把定时器清空

```javascript
  <script>
    const box = document.querySelector('.box')
    let i = 1  // 让这个变量++
    // 鼠标移动函数
    function mouseMove() {
      box.innerHTML = ++i
      // 如果里面存在大量操作 dom 的情况，可能会卡顿
    }
    // 防抖函数
    function throttle(fn, t) {
      let timeId
      return function () {
        // 如果有定时器就清除
        if (!timeId)
        // 开启定时器 200
        timeId = setTimeout(function () {
          fn()
          timeId=null;
        }, t)
      }
    }
    // box.addEventListener('mousemove', mouseMove)
    box.addEventListener('mousemove', throttle(mouseMove, 500))

  </script>
```

注意：这里清空定时器不能使用clearTimeout，而是将timeId设置为null。因为在setTimeoput中是无法清楚定时器的。
